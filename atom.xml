<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-08T15:10:16.468Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>表达式</title>
    <link href="http://example.com/2022/11/08/[C++11]lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://example.com/2022/11/08/[C++11]lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-11-08T15:10:16.000Z</published>
    <updated>2022-11-08T15:10:16.468Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>std::functional</title>
    <link href="http://example.com/2022/11/08/[C++11]functional/"/>
    <id>http://example.com/2022/11/08/[C++11]functional/</id>
    <published>2022-11-08T15:09:42.000Z</published>
    <updated>2022-11-08T15:09:42.911Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>一些日常使用到的函数</title>
    <link href="http://example.com/2022/11/06/%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/"/>
    <id>http://example.com/2022/11/06/%E4%B8%80%E4%BA%9B%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</id>
    <published>2022-11-06T15:44:48.000Z</published>
    <updated>2022-11-06T15:50:02.363Z</updated>
    
    <content type="html"><![CDATA[<h4 id="find-first-not-of-函数"><a href="#find-first-not-of-函数" class="headerlink" title="find_first_not_of()函数"></a><code>find_first_not_of()</code>函数</h4><p>正向查找在原字符串中第一个与指定字符串（或字符）中的任一字符都不匹配的字符，返回它的位置。若查找失败，则返回<code>npos</code>。（<code>npos</code>定义为保证大于任何有效下标的值。）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(name.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._0123456789&quot;</span>)</span><br><span class="line">        != std::string::npos)&#123;</span><br><span class="line">    <span class="comment">//name存在非法字符，记录错误信息，抛出异常</span></span><br><span class="line">    <span class="built_in">MUHUI_LOG_ERROR</span>(<span class="built_in">MUHUI_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name invalid &quot;</span> &lt;&lt; name;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="find-last-not-of-函数"><a href="#find-last-not-of-函数" class="headerlink" title="find_last_not_of()函数"></a><code>find_last_not_of()</code>函数</h4><p>正向查找在原字符串中最后一个与指定字符串（或字符）中的任一字符都不匹配的字符，返回它的位置。若查找失败，则返回<code>npos</code>。（<code>npos</code>定义为保证大于任何有效下标的值。）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;find-first-not-of-函数&quot;&gt;&lt;a href=&quot;#find-first-not-of-函数&quot; class=&quot;headerlink&quot; title=&quot;find_first_not_of()函数&quot;&gt;&lt;/a&gt;&lt;code&gt;find_first_not_of()</summary>
      
    
    
    
    <category term="function" scheme="http://example.com/categories/function/"/>
    
    
    <category term="日常记录" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"/>
    
  </entry>
  
  <entry>
    <title>关于C++子类构造函数初始化及父类构造函数初始化</title>
    <link href="http://example.com/2022/11/06/%E5%85%B3%E4%BA%8EC-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <id>http://example.com/2022/11/06/%E5%85%B3%E4%BA%8EC-%E5%AD%90%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%88%B6%E7%B1%BB%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%8C%96/</id>
    <published>2022-11-06T14:55:56.000Z</published>
    <updated>2022-11-06T15:44:12.108Z</updated>
    
    <content type="html"><![CDATA[<ul><li>父类没有声明构造函数</li></ul><p>(1) 子类也没有声明自己的构造函数，则父类和子类均由编译器生成默认的构造函数。</p><p>(2) 子类中声明了构造函数(无参或者带参)，则子类的构造函数可以写成任何形式，不用顾忌父类的构造函数。在创建子类对象时，先调用父类默认的构造函数编译器自动生成，再调用子类的构造函数。</p><ul><li>父类只声明了无参构造函数</li></ul><p>如果子类的构造函数没有显式地调用父类的构造，则将会调用父类的无参构造函数。也就是说，父类的无参构造函数将会被隐式地调用。</p><ul><li>父类只声明了带参构造函数</li></ul><p>在这种情况下，要特别注意。因为父类只有带参的构造函数，所以如果子类中的构造函数没有显示地调用父类的带参构造函数，则会报错，所以必需显示地调用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">animal</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:       <span class="comment">//成员变量，声明为protected或者public，这里选择protected</span></span><br><span class="line">    <span class="type">int</span> height;  <span class="comment">//若声明为private，则不能被子类继承访问，会报错</span></span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">animal</span>(<span class="type">int</span> height,<span class="type">int</span> weight)   <span class="comment">//带参的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;height=height;</span><br><span class="line">        <span class="keyword">this</span>-&gt;weight=weight;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;animal的带参构造函数被调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">animal</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;animal的析构函数被调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">fish</span>:<span class="keyword">public</span> animal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">fish</span>():<span class="built_in">animal</span>(height,weight) <span class="comment">//显示调用父类的构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;fish的构造函数被调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">fish</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;fish的析构函数被调用&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;父类没有声明构造函数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;(1) 子类也没有声明自己的构造函数，则父类和子类均由编译器生成默认的构造函数。&lt;/p&gt;
&lt;p&gt;(2) 子类中声明了构造函数(无参或者带参)，则子类的构造函数可以写成任何形式，不用顾忌父类的构造函数。在创建子类对</summary>
      
    
    
    
    <category term="C++11" scheme="http://example.com/categories/C-11/"/>
    
    
    <category term="继承" scheme="http://example.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title>关于dynamic_cast和typename</title>
    <link href="http://example.com/2022/11/06/%E5%85%B3%E4%BA%8Edynamic-cast%E5%92%8Ctypename/"/>
    <id>http://example.com/2022/11/06/%E5%85%B3%E4%BA%8Edynamic-cast%E5%92%8Ctypename/</id>
    <published>2022-11-06T14:54:38.000Z</published>
    <updated>2022-11-06T15:40:48.129Z</updated>
    
    <content type="html"><![CDATA[<h4 id="typename说明"><a href="#typename说明" class="headerlink" title="typename说明"></a>typename说明</h4><p>  <code>typename</code>是一个C++程序设计语言中的关键字。当用于泛型编程时是另一术语”class”的同义词。这个关键字用于指出模板声明（或定义）中的非独立名称（dependent names）是类型名，而非变量名。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="comment">//typename 指出模板声明（或定义）中的非独立名称是类型名，而非变量名</span></span><br><span class="line"><span class="comment">//Lookup是一个返回类型为ConfigVar&lt;T&gt;::ptr 的静态成员函数</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">Lookup</span><span class="params">(<span class="type">const</span> std::string&amp; name,</span></span></span><br><span class="line"><span class="params"><span class="function">                <span class="type">const</span> T&amp; default_val, <span class="type">const</span> std::string&amp; description = <span class="string">&quot;&quot;</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//查找name是否在map内</span></span><br><span class="line">    <span class="keyword">auto</span> tmp = <span class="built_in">Lookup</span>&lt;T&gt;(name);</span><br><span class="line">    <span class="keyword">if</span>(tmp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//存在，记录信息，返回tmp</span></span><br><span class="line">        <span class="built_in">MUHUI_LOG_INFO</span>(<span class="built_in">MUHUI_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name  = &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; exists&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//不存在，先查询name是否存在非法字符</span></span><br><span class="line">    <span class="keyword">if</span>(name.<span class="built_in">find_first_not_of</span>(<span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ._0123456789&quot;</span>)</span><br><span class="line">            != std::string::npos)&#123;</span><br><span class="line">        <span class="comment">//name存在非法字符，记录错误信息，抛出异常</span></span><br><span class="line">        <span class="built_in">MUHUI_LOG_ERROR</span>(<span class="built_in">MUHUI_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;Lookup name invalid &quot;</span> &lt;&lt; name;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">invalid_argument</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新建ConfigVar对象指针，并将其加入到map中</span></span><br><span class="line">    <span class="keyword">typename</span> ConfigVar&lt;T&gt;::<span class="function">ptr <span class="title">v</span><span class="params">(<span class="keyword">new</span> ConfigVar&lt;T&gt;(name, default_val, description))</span></span>;</span><br><span class="line">    s_datas[name] = v;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="关于C-中的dynamic-cast和dynamic-pointer-cast"><a href="#关于C-中的dynamic-cast和dynamic-pointer-cast" class="headerlink" title="关于C++中的dynamic_cast和dynamic_pointer_cast"></a>关于C++中的<code>dynamic_cast</code>和<code>dynamic_pointer_cast</code></h4><ul><li>将一个基类对象指针（或引用）<code>cast</code>到继承类指针，<code>dynamic_cast</code>会根据基类指针是否真正指向继承类指针来做相应处理。</li><li>主要用途：将基类的指针或引用安全地转换成派生类的指针或引用，并用派生类的指针或引用调用非虚函数。如果是基类指针或引用调用的是虚函数无需转换就能在运行时调用派生类的虚函数。</li></ul><h5 id="转换方式"><a href="#转换方式" class="headerlink" title="转换方式"></a>转换方式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//type必须是一个类类型且必须是一个有效的指针 </span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt; type* &gt;(e) </span><br><span class="line"><span class="comment">//type必须是一个类类型且必须是一个左值 </span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt; type&amp; &gt;(e) </span><br><span class="line"><span class="comment">//type必须是一个类类型且必须是一个右值</span></span><br><span class="line"><span class="built_in">dynamic_cast</span>&lt; type&amp;&amp; &gt;(e) </span><br></pre></td></tr></table></figure><p>e的类型必须符合以下三个条件中的任何一个： </p><ol><li>e的类型是目标类型type的公有派生类 </li><li>e的类型是目标type的共有基类 </li><li>e的类型就是目标type的类型<h5 id="dynamic-pointer-cast"><a href="#dynamic-pointer-cast" class="headerlink" title="dynamic_pointer_cast"></a><code>dynamic_pointer_cast</code></h5><code>dynamic_pointer_cast</code>与<code>dynamic_cast</code>用法类似，当指针是智能指针时候，向下转换，用<code>dynamic_Cast</code> 则编译不能通过，此时需要使用<code>dynamic_pointer_cast</code>。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;typename说明&quot;&gt;&lt;a href=&quot;#typename说明&quot; class=&quot;headerlink&quot; title=&quot;typename说明&quot;&gt;&lt;/a&gt;typename说明&lt;/h4&gt;&lt;p&gt;  &lt;code&gt;typename&lt;/code&gt;是一个C++程序设计语言中的关</summary>
      
    
    
    
    <category term="C++11" scheme="http://example.com/categories/C-11/"/>
    
    
    <category term="日常学习" scheme="http://example.com/tags/%E6%97%A5%E5%B8%B8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>boost/lexical_cast.hpp的简单使用方法</title>
    <link href="http://example.com/2022/11/06/boost-lexical-cast-hpp%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/11/06/boost-lexical-cast-hpp%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2022-11-06T14:52:44.000Z</published>
    <updated>2022-11-06T15:28:04.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="lexical-cast说明"><a href="#lexical-cast说明" class="headerlink" title="lexical_cast说明"></a><code>lexical_cast</code>说明</h4><p>顾名思义，lexical_cast库进行”字面值“的转换，类似C中的atoi()函数，可以进行字符串与整数&#x2F;浮点数之间的字面转换</p><ul><li>标准C和c++库提供了许多用于执行此类转换的工具。但是，它们的易用性、可扩展性和安全性各不相同。</li><li>例如，C语言中的 <code>atoi()</code>、<code>atof()</code> 等函数，它们可以把字符串转换成数值，但是这种转换是不对称的，不存在比如 <code>itoa()</code> 这样的方向转换(C标准未提供，但有的编译期产生会提供)，要想把数值转换为字符串，只能使用不安全的 <code>printf()</code>。</li><li><code>lexical_cast</code> 函数模板提供了一种方便且一致的形式，用于支持以文本形式表示的任意类型之间的公共转换。它提供的简化是这种转换在表达级上的便利。</li><li>对于更复杂的转换，例如需要比 <code>lexical_cast</code> 的默认行为提供更严格的精度或格式控制时，建议使用常规的 <code>std::stringstream</code> 方法。</li><li>在数值到数值的转换中，<code>boost::numeric_cast</code> 可能提供比 <code>lexical_cast</code> 更合理的行为。</li></ul><h4 id="使用形式"><a href="#使用形式" class="headerlink" title="使用形式"></a>使用形式</h4><ul><li>标准形式<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准形式，转换数字和字符</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> N&gt;</span></span><br><span class="line"><span class="function">T <span class="title">lexical_cast</span><span class="params">(<span class="type">const</span> N&amp; val)</span></span>;</span><br></pre></td></tr></table></figure></li><li>效果：将 <code>val</code> 流式处理的结果返回到基于标准库字符串的流中，然后作为模板对象输出，如果模板是<code>std::string</code>   或 <code>std::wstring</code> ，流将提取出字符串的全部内容，包括空格，而不是依赖于默认操作符 <code>&gt;&gt;</code> 的行为。如果转换失败，将引发 <code>bad_lexical_cast</code>  异常</li><li>说明：它有两个模板参数，<strong>T</strong> 需要我们手工指定，是转换后的模板类型，通常是数字类型或者 <code>std::string</code> ；而第二个参数 <strong>N</strong> 不必写出，因为它可以通过函数参数推导出来，所以调用的形式是： <code>lexical_cast&lt;T&gt;(...)</code></li><li>转换C字符串</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换C字符串</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">lexical_cast</span><span class="params">(<span class="type">const</span> AnyCharacterType* chars, std::<span class="type">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>效果：接受计数字符数组作为输入参数，并将它们作为 <strong>T</strong>对象流输出。如果转换不成功，将引发 <code>bad_lexical_cast</code> 异常。这个调用对于处理非零终止字符数组或处理字符数组的某些部分可能有用。</li><li>说明：它是专门用来处理C字符串的，除了 <code>const char</code> 外还支持 <code>unsigned char</code> 、 <code>const wchar_t*</code> 等其他字符类型，它只接受一个模板参数<strong>T</strong>，指明转换后的目标类型。参数 <code>chars</code> 和 <code>counts</code> 则标记了要转换的字符串的范围</li></ul><h4 id="转换对象的要求"><a href="#转换对象的要求" class="headerlink" title="转换对象的要求"></a>转换对象的要求</h4><ul><li><strong>N</strong>是可流输出的(OutputStreamable)，即定义了一个操作符**&lt;&lt;**;</li><li><strong>T</strong>是可流输入的(InputStreamable)，即义了一个操作符**&gt;&gt;**;</li><li><strong>T</strong>是可复制的;</li><li><strong>T</strong>是可默认构造的，这意味着可以默认初始化该类型的对象。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="built_in">lexical_cast</span>&lt;<span class="type">int</span>&gt;(<span class="string">&quot;100&quot;</span>);</span><br><span class="line"><span class="type">long</span> y = <span class="built_in">lexical_cast</span>&lt;<span class="type">long</span>&gt;(<span class="string">&quot;2000&quot;</span>);</span><br><span class="line"><span class="type">float</span> pai = <span class="built_in">lexical_cast</span>&lt;<span class="type">float</span>&gt;(<span class="string">&quot;3.14159e5&quot;</span>);</span><br><span class="line"><span class="type">double</span>  e = <span class="built_in">lexical_cast</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;2.71828&quot;</span>);</span><br><span class="line"><span class="type">double</span> f = <span class="built_in">lexical_cast</span>&lt;<span class="type">double</span>&gt;(<span class="string">&quot;1.414.x&quot;</span>, <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">std::string str = <span class="built_in">lexical_cast</span>&lt;std::string&gt;(<span class="number">345</span>);</span><br><span class="line">std::cout &lt;&lt; str &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="built_in">lexical_cast</span>&lt;std::string&gt;(<span class="number">0.618</span>) &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; <span class="built_in">lexical_cast</span>&lt;std::string&gt;(<span class="number">0x10</span>);</span><br></pre></td></tr></table></figure><ul><li><strong>注意 ：</strong></li></ul><p>使用<code>lexical_cast</code>时要注意，待转换成数字的字符串只能有数字和小数点，不能出现字母或者其他非数字字符(表示指数e&#x2F;E除外)，业就是说，<code>lexical_cast</code>不能抓换比如<code>”123L“</code>，<code>”0x123“</code>这样的字符串。而且<code>lexical_cast</code>不支持高级的格式控制，不能把数字转换成其他格式的字符串，如果需要更高级的搁置控制，则应该用<code>std::stringstream</code>或者<code>boost::format</code>。</p><h4 id="异常处理：bad-lexical-cast"><a href="#异常处理：bad-lexical-cast" class="headerlink" title="异常处理：bad_lexical_cast"></a>异常处理：<code>bad_lexical_cast</code></h4><ul><li><p>当<code>lexical_cast</code>无法执行转换操作时会抛出异常<code>bad_lexical_cast</code> ，它是<code>std::bad_cast</code>的派生类;</p></li><li><p>在使用<code>lexcial_cast</code>转换时我们应该使用<code>try/catch</code>块来保护代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">fromString</span><span class="params">(<span class="type">const</span> std::string&amp; val)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        m_val = boost::<span class="built_in">lexical_cast</span>&lt;T&gt;(val);</span><br><span class="line">    &#125;<span class="built_in">catch</span>(std::exception&amp; e)&#123;</span><br><span class="line">        <span class="built_in">MUHUI_LOG_ERROR</span>(<span class="built_in">MUHUI_LOG_ROOT</span>()) &lt;&lt; <span class="string">&quot;ConfigVar::fromString exception&quot;</span></span><br><span class="line">            &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;convert: string to&quot;</span> &lt;&lt; <span class="built_in">typeid</span>(m_val).<span class="built_in">name</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>try_lexical_convert()</code> 可以安全的转换字面值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">assert</span>(!conversion::<span class="built_in">try_lexical_convert</span>(<span class="string">&quot;0x100&quot;</span>, x));</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;lexical-cast说明&quot;&gt;&lt;a href=&quot;#lexical-cast说明&quot; class=&quot;headerlink&quot; title=&quot;lexical_cast说明&quot;&gt;&lt;/a&gt;&lt;code&gt;lexical_cast&lt;/code&gt;说明&lt;/h4&gt;&lt;p&gt;顾名思义，lexi</summary>
      
    
    
    
    <category term="boost" scheme="http://example.com/categories/boost/"/>
    
    
    <category term="lexical_cast.hpp" scheme="http://example.com/tags/lexical-cast-hpp/"/>
    
  </entry>
  
  <entry>
    <title>智能指针-shared_ptr</title>
    <link href="http://example.com/2022/11/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared-ptr/"/>
    <id>http://example.com/2022/11/05/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88-shared-ptr/</id>
    <published>2022-11-05T14:27:56.000Z</published>
    <updated>2022-11-05T15:04:06.963Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、关于RALL机制-Resource-Acquisition-Is-Initialization"><a href="#1、关于RALL机制-Resource-Acquisition-Is-Initialization" class="headerlink" title="1、关于RALL机制(Resource Acquisition Is Initialization)"></a>1、关于RALL机制(Resource Acquisition Is Initialization)</h3><p>RAII 意为“资源获取即初始化”。其核心是把资源和对象的生命周期绑定，对象创建获取资源，对象销毁释放资源。在 RAII 的指导下，C++ 把底层的资源管理问题提升到了对象生命周期管理的更高层次。<br>使用C++时，让人头疼的时内存管理，使用RALL机制可以实现资源的自动释放，我们可以将资源托管给某个对象，或者说这个对象是资源的代理，在这个对象析构的时候完成资源的释放。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个模板类, 负责资源的释放, 当资源生命周期结束, 自动释放资源;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">auto_release_ptr</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">auto_release_ptr</span>(T *t) :<span class="type">_t</span>(t)&#123;&#125;;  </span><br><span class="line">    ~<span class="built_in">auto_release_ptr</span>()  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">delete</span> <span class="type">_t</span>;  </span><br><span class="line">    &#125;;  </span><br><span class="line"></span><br><span class="line">    <span class="function">T * <span class="title">getPtr</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="type">_t</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    T *<span class="type">_t</span>;  </span><br><span class="line">&#125;;  </span><br></pre></td></tr></table></figure><h3 id="2、关于shared-ptr智能指针"><a href="#2、关于shared-ptr智能指针" class="headerlink" title="2、关于shared_ptr智能指针"></a>2、关于<code>shared_ptr</code>智能指针</h3><p>多个 <code>shared_ptr</code> 智能指针可以共同使用同一块堆内存。并且，由于该类型智能指针在实现上采用的是引用计数机制，即便有一个 <code>shared_ptr</code> 指针放弃了堆内存的“使用权”（引用计数减 1），也不会影响其他指向同一堆内存的 <code>shared_ptr</code> 指针（只有引用计数为 0 时，堆内存才会被自动释放）。</p><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li>构造空智能指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p1;             <span class="comment">//不传入任何实参</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="literal">nullptr</span>)</span></span>;    <span class="comment">//传入空指针 nullptr</span></span><br></pre></td></tr></table></figure></li><li>构造时明确指针指向<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p3</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br></pre></td></tr></table></figure></li><li>使用 <code>std::make_shared&lt;T&gt;</code> 初始化指针<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; p3 = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br></pre></td></tr></table></figure></li><li>关于 <code>shared_ptr</code> 的拷贝&#x2F;移动构造函数<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="comment">// p3 是左值</span></span><br><span class="line"><span class="comment">//std::shared_ptr&lt;int&gt; p4 = p3;</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p4</span><span class="params">(p3)</span></span>;</span><br><span class="line"><span class="comment">//调用移动构造函数</span></span><br><span class="line"><span class="comment">//std::shared_ptr&lt;int&gt; p5 = std::move(p4);</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p5</span><span class="params">(std::move(p4))</span></span>; </span><br></pre></td></tr></table></figure>对于 <code>std::move(p4)</code> 来说，该函数会强制将 <code>p4</code> 转换成对应的右值，因此初始化 <code>p5</code> 调用的是移动构造函数。另外和调用拷贝构造函数不同，用 <code>std::move(p4)</code> 初始化 <code>p5</code>，会使得 <code>p5</code> 拥有了 <code>p4</code> 的堆内存，而 <code>p4</code> 则变成了空智能指针</li></ul><p>**注意 : **同一普通指针不能同时为多个 <code>shared_ptr</code> 对象赋值，否则会导致程序发生异常。</p><ul><li>在初始化 <code>shared_ptr</code> 智能指针时，可以自定义所指堆内存的释放规则，这样当堆内存的引用计数为 0 时，会优先调用我们自定义的释放规则。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用lambda表达式</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p7</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>], [](<span class="type">int</span>* p) &#123;<span class="keyword">delete</span>[]p; &#125;)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="shared-ptr-lt-T-gt-模板类提供的成员方法"><a href="#shared-ptr-lt-T-gt-模板类提供的成员方法" class="headerlink" title="shared_ptr&lt;T&gt;模板类提供的成员方法"></a><code>shared_ptr&lt;T&gt;</code>模板类提供的成员方法</h4><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td><code>swap()</code></td><td>交换 2 个相同类型 <code>shared_ptr</code> 智能指针的内容。</td></tr><tr><td><code>reset()</code></td><td>当函数没有实参时，该函数会使当前 <code>shared_ptr</code> 所指堆内存的引用计数减 1，同时将当前对象重置为一个空指针；当为函数传递一个新申请的堆内存时，则调用该函数的 <code>shared_ptr</code> 对象会获得该存储空间的所有权，并且引用计数的初始值为 1。</td></tr><tr><td><code>get()</code></td><td>获得 <code>shared_ptr</code> 对象内部包含的普通指针。</td></tr><tr><td><code>use_count()</code></td><td>返回同当前 <code>shared_ptr</code> 对象（包括它）指向相同的所有 <code>shared_ptr</code> 对象的数量。</td></tr><tr><td><code>unique()</code></td><td>判断当前 <code>shared_ptr</code> 对象指向的堆内存，是否不再有其它 <code>shared_ptr</code> 对象再指向它。</td></tr><tr><td><code>operator bool()</code></td><td>判断当前 <code>shared_ptr</code> 对象是否为空智能指针，如果是空指针，返回 <code>false</code>；反之，返回 true。</td></tr><tr><td><code>operator=()</code></td><td>重载赋值号，使得同一类型的 <code>shared_ptr</code> 智能指针可以相互赋值。</td></tr><tr><td><code>operator*()</code></td><td>重载 <code>*</code> 号，获取当前 <code>shared_ptr</code> 智能指针对象指向的数据。</td></tr><tr><td><code>operator-&gt;()</code></td><td>重载 <code>-&gt;</code> 号，当智能指针指向的数据类型为自定义的结构体时，通过 -&gt; 运算符可以获取其内部的指定成员。</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1、关于RALL机制-Resource-Acquisition-Is-Initialization&quot;&gt;&lt;a href=&quot;#1、关于RALL机制-Resource-Acquisition-Is-Initialization&quot; class=&quot;headerlink&quot; t</summary>
      
    
    
    
    <category term="智能指针" scheme="http://example.com/categories/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    
    <category term="shared_ptr" scheme="http://example.com/tags/shared-ptr/"/>
    
  </entry>
  
  <entry>
    <title>复制带随机指针的链表</title>
    <link href="http://example.com/2022/11/03/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/11/03/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8/</id>
    <published>2022-11-03T06:59:32.000Z</published>
    <updated>2022-11-03T07:13:59.285Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题目描述</strong><br>给你一个长度为 <code>n</code> 的链表，每个节点包含一个额外增加的随机指针 <code>random</code> ，该指针可以指向链表中的任何节点或空节点。</p><p><strong>示例</strong><br><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/%E5%A4%8D%E5%88%B6%E5%B8%A6%E9%9A%8F%E6%9C%BA%E6%8C%87%E9%92%88%E7%9A%84%E9%93%BE%E8%A1%A8.3s3afofhj5e0.webp" alt="复制带随机指针的链表"></p><p><strong>思路</strong></p><ul><li>哈希表<ul><li>创建一个哈希表，再遍历原链表，遍历的同时再不断创建新节点（key–&gt;oldnode，value–&gt;newnode）</li><li>再次遍历原链表，设置新链表的next和random指针</li></ul></li></ul><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/%E9%93%BE%E8%A1%A8%E5%93%88%E5%B8%8C%E5%AD%98%E5%82%A8.6ssn5nv4zmo0.webp" alt="链表哈希存储"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=138 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [138] 复制带随机指针的链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node *random;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val)</span><br><span class="line">    &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="function">Node *<span class="title">copyRandomList</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// key--&gt;old node, value--&gt;new node</span></span><br><span class="line">        unordered_map&lt;Node *, Node *&gt; map;</span><br><span class="line">        Node *p = head;</span><br><span class="line">        <span class="comment">//将原节点和新节点放入map</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newnode = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            map[p] = newnode;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历单链表， 设置新节点的next和random</span></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newNode = map.<span class="built_in">at</span>(p);</span><br><span class="line">            <span class="comment">//设置next</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newNode-&gt;next = map.<span class="built_in">at</span>(p-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置random</span></span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                newNode-&gt;random = map.<span class="built_in">at</span>(p-&gt;random);</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.<span class="built_in">at</span>(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function">Node *<span class="title">copyRandomList2</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *p = head;</span><br><span class="line">        <span class="comment">//在每个原节点的后面插入一个新节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Node *newNode = <span class="keyword">new</span> <span class="built_in">Node</span>(p-&gt;val);</span><br><span class="line">            newNode-&gt;next = p-&gt;next;</span><br><span class="line">            p-&gt;next = newNode;</span><br><span class="line">            p = newNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        p = head;</span><br><span class="line">        <span class="comment">//设置新节点的随机节点</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;random != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p-&gt;next-&gt;random = p-&gt;random-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Node *newhead = <span class="keyword">new</span> <span class="built_in">Node</span>(<span class="number">-1</span>);</span><br><span class="line">        p = head;</span><br><span class="line">        Node *node = newhead;</span><br><span class="line">        <span class="comment">//分离两个新链表</span></span><br><span class="line">        <span class="keyword">while</span> (p != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            node-&gt;next = p-&gt;next;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">            p-&gt;next = node-&gt;next;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newhead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;给你一个长度为 &lt;code&gt;n&lt;/code&gt; 的链表，每个节点包含一个额外增加的随机指针 &lt;code&gt;random&lt;/code&gt; ，该指针可以指向链表中的任何节点或空节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="链表" scheme="http://example.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++内存池</title>
    <link href="http://example.com/2022/11/02/C++%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    <id>http://example.com/2022/11/02/C++%E5%86%85%E5%AD%98%E6%B1%A0/</id>
    <published>2022-11-02T12:50:28.000Z</published>
    <updated>2022-11-02T13:54:05.518Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ol><li>先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象；</li><li>每个对象连同一个指向下一个对象的指针一起构成一个内存节点（Memory Node）。各个空闲的内存节点通过指针形成一个链表，链表的每一个内存节点都是一块可供分配的内存空间；</li><li>某个内存节点一旦分配出去，从空闲内存节点链表中去除；</li><li>一旦释放了某个内存节点的空间，又将该节点重新加入空闲内存节点链表；</li><li>如果一个内存块的所有内存节点分配完毕，若程序继续申请新的对象空间，则会再次申请一个内存块来容纳新的对象。新申请的内存块会加入内存块链表中。</li></ol><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/%E5%86%85%E5%AD%98%E6%B1%A0.1qhbt982i134.webp" alt="内存池"></p><h5 id="内存块的数据结构设计"><a href="#内存块的数据结构设计" class="headerlink" title="内存块的数据结构设计"></a>内存块的数据结构设计</h5><ul><li><p>成员函数</p><ul><li><code>void pop(int len)</code> 处理<code>len</code>长度的数据;</li><li><code>void adjust()</code> 将处理完的数据清空，将未处理完的数据移动到<code>buf</code>的首地址；</li><li><code>void copy(const io_buf* other)</code>将其他内存块的数据拷贝；</li><li><code>void clean()</code>清空当前内存块；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *定义一个buffer一块内存的数据结构体</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">io_buf</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//构造创建一个size大小的buf</span></span><br><span class="line">    <span class="built_in">io_buf</span>(<span class="type">int</span> size);</span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clean</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//处理长度为len的数据，移动head</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> len)</span></span>; <span class="comment">//len表示已经处理的数据的长度</span></span><br><span class="line">    <span class="comment">//将已经处理的数据清空（内存抹去）， 将未处理的数据移到buf的首地址，length会减小</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">adjust</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//将其他的io_buf对象拷贝到自己中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">copy</span><span class="params">(<span class="type">const</span> io_buf* other)</span></span>;</span><br><span class="line">    <span class="comment">//当前buf的总容量</span></span><br><span class="line">    <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">//当前buf的有效数据长度</span></span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">    <span class="comment">//当前buf的有效数据的头部索引</span></span><br><span class="line">    <span class="type">int</span> head;</span><br><span class="line">    <span class="comment">//当前buf的内存首地址</span></span><br><span class="line">    <span class="type">char</span>* data;   </span><br><span class="line">    <span class="comment">//存在多个io_buf，采用链表的形式进行管理</span></span><br><span class="line">    io_buf* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="内存块的数据结构实现"><a href="#内存块的数据结构实现" class="headerlink" title="内存块的数据结构实现"></a>内存块的数据结构实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;io_buf.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//构造创建一个size大小的buf</span></span><br><span class="line">io_buf::<span class="built_in">io_buf</span>(<span class="type">int</span> size)</span><br><span class="line">&#123;</span><br><span class="line">    capacity = size;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    next = <span class="literal">NULL</span>;</span><br><span class="line">    data = <span class="keyword">new</span> <span class="type">char</span>[size];<span class="comment">//开辟内存</span></span><br><span class="line">    <span class="built_in">assert</span>(data != <span class="literal">NULL</span>); <span class="comment">//断言，如果data==NULL，那么程序直接退出</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_buf::clean</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length = head = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理长度为len的数据，移动head</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_buf::pop</span><span class="params">(<span class="type">int</span> len)</span> <span class="comment">//len表示已经处理的数据的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    length -= len;</span><br><span class="line">    head += len;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将已经处理的数据清空（内存抹去）， 将未处理的数据移到buf的首地址，length会减小</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_buf::adjust</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//length == 0 代表全部的数据已经处理完</span></span><br><span class="line">        <span class="keyword">if</span>(length != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//memcpy 是头指针后移拷贝，memmove 是尾指针前移拷贝</span></span><br><span class="line">            <span class="built_in">memmove</span>(data, data+head, length);</span><br><span class="line">        &#125;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将其他的io_buf对象拷贝到自己中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">io_buf::copy</span><span class="params">(<span class="type">const</span> io_buf* other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memcpy</span>(data, other-&gt;data + other-&gt;head,other-&gt;length);</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">    length = other-&gt;length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="多线程内存池数据结构设计"><a href="#多线程内存池数据结构设计" class="headerlink" title="多线程内存池数据结构设计"></a>多线程内存池数据结构设计</h5></li></ul></li><li><p>单例模式，保证内存池在程序运行过程中只存在一个</p></li><li><p>成员函数(单例访问)</p><ul><li><code>io_buf* alloc_buf(int N);io_buf* alloc_buf();</code> 从内存池中申请一块内存</li><li><code>void revert(io_buf* buffer);</code> 重置一个i<code>o_buf</code>放回<code>pool</code>中</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;io_buf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ext/hash_map&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> __gnu_cxx::hash_map&lt;<span class="type">int</span>, io_buf*&gt; <span class="type">pool_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一些内存的刻度</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">MEM_CAP</span>&#123;</span><br><span class="line">    m4K = <span class="number">4096</span>,</span><br><span class="line">    m16K = <span class="number">16384</span>,</span><br><span class="line">    m64K = <span class="number">65536</span>,</span><br><span class="line">    m256K = <span class="number">262114</span>,</span><br><span class="line">    m1M = <span class="number">1048576</span>,</span><br><span class="line">    m4M = <span class="number">4194304</span>,</span><br><span class="line">    m8M = <span class="number">8388608</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总内存池的大小限制 单位是kb</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_LIMIT (5U * 1024 * 1024)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">buf_pool</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//只能初始化一个对象</span></span><br><span class="line">    <span class="comment">//初始化单例对象</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        _instance = <span class="keyword">new</span> <span class="built_in">buf_pool</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提供一个静态获取instance的方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> buf_pool* <span class="title">instance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//保证init方法在进程的生命周期只执行一次</span></span><br><span class="line">        <span class="built_in">pthread_once</span>(&amp;_once, init);</span><br><span class="line">        <span class="keyword">return</span> _instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从内存池中申请一块内存</span></span><br><span class="line">    <span class="function">io_buf* <span class="title">alloc_buf</span><span class="params">(<span class="type">int</span> N)</span></span>;</span><br><span class="line">    <span class="function">io_buf* <span class="title">alloc_buf</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重置一个io_buf放回pool中</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">revert</span><span class="params">(io_buf* buffer)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//====创建单例====</span></span><br><span class="line">    <span class="comment">//构造函数私有化</span></span><br><span class="line">    <span class="built_in">buf_pool</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造函数私有化</span></span><br><span class="line">    <span class="built_in">buf_pool</span>(<span class="type">const</span> buf_pool&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//=运算符私有化</span></span><br><span class="line">    <span class="type">const</span> buf_pool&amp; <span class="keyword">operator</span>=(<span class="type">const</span> buf_pool&amp;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟内存池空间</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">malloc_mem</span><span class="params">(MEM_CAP, <span class="type">int</span> num)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单例的对象</span></span><br><span class="line">    <span class="type">static</span> buf_pool* _instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于保证创建单例的一个方法，全局只执行一次,加锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> _once;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//==== buf_pool 属性 ====</span></span><br><span class="line">    <span class="comment">//存放所有io_buf的map句柄</span></span><br><span class="line">    <span class="type">pool_t</span> _pool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前内存池总体大小</span></span><br><span class="line">    <span class="type">uint64_t</span> _total_mem;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保护pool map增删改查的锁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_mutex_t</span> _mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="内存池的数据结构实现"><a href="#内存池的数据结构实现" class="headerlink" title="内存池的数据结构实现"></a>内存池的数据结构实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;io_buf.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;buf_pool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//单例的对象</span></span><br><span class="line">buf_pool* buf_pool::_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于保证创建单例的一个方法，全局只执行一次,加锁</span></span><br><span class="line"><span class="type">pthread_once_t</span> buf_pool::_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化锁</span></span><br><span class="line"><span class="type">pthread_mutex_t</span> buf_pool::_mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数私有化</span></span><br><span class="line"><span class="comment">//buf_pool --&gt; [m4K] --&gt; io_buf..io_buf..io_buf</span></span><br><span class="line"><span class="comment">//             [m16K] --&gt; io_buf..io_buf..io_buf</span></span><br><span class="line">buf_pool::<span class="built_in">buf_pool</span>():</span><br><span class="line">    _total_mem(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//开辟4K buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m4K, <span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟16K buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m16K, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟64K buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m64K, <span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟256K buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m256K, <span class="number">200</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开辟1m buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m1M, <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟4m buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m4M, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开辟8m buf内存池</span></span><br><span class="line">    <span class="built_in">malloc_mem</span>(m8M, <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从内存池中申请一块内存</span></span><br><span class="line"><span class="function">io_buf* <span class="title">buf_pool::alloc_buf</span><span class="params">(<span class="type">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="comment">// 1 找到N最接近的 一个刻度链表 返回一个io_buf</span></span><br><span class="line">    <span class="keyword">if</span> (N &lt;= m4K) &#123;</span><br><span class="line">        index = m4K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( N &lt;= m16K) &#123;</span><br><span class="line">        index = m16K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( N &lt;= m64K) &#123;</span><br><span class="line">        index = m64K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( N &lt;= m256K) &#123;</span><br><span class="line">        index = m256K;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( N &lt;= m1M) &#123;</span><br><span class="line">        index = m1M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( N &lt;= m4M) &#123;</span><br><span class="line">        index = m4M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( N &lt;= m8M) &#123;</span><br><span class="line">        index = m8M;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2 如果该index内存已经没有了，需要额外申请内存</span></span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;_mutex);</span><br><span class="line">    <span class="keyword">if</span>(_pool[index] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">    <span class="comment">//index链表为空，需要新申请index大小的io_buf</span></span><br><span class="line">        <span class="keyword">if</span>(_total_mem + index/<span class="number">1024</span> &gt;= MEM_LIMIT)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;already use to many memory!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        io_buf* new_buf = <span class="keyword">new</span> <span class="built_in">io_buf</span>(index);</span><br><span class="line">        <span class="keyword">if</span>(new_buf == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;new io_buf error\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        _total_mem += index/<span class="number">1024</span>;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">        <span class="keyword">return</span> new_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3 如果index有内存，从pool中拆除一块内存返回</span></span><br><span class="line">    io_buf* target = _pool[index];</span><br><span class="line">    _pool[index] = target-&gt;next;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">    target-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">io_buf* <span class="title">buf_pool::alloc_buf</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">alloc_buf</span>(m4K);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重置一个io_buf放回pool中</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buf_pool::revert</span><span class="params">(io_buf* buffer)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将buffer放回pool中</span></span><br><span class="line">    <span class="comment">//index 是属于pool中的哪个链表</span></span><br><span class="line">    <span class="type">int</span> index = buffer-&gt;capacity;</span><br><span class="line">    buffer-&gt;length = <span class="number">0</span>;</span><br><span class="line">    buffer-&gt;head = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">pthread_mutex_lock</span>(&amp;_mutex);</span><br><span class="line">    <span class="comment">//断言，一定可以找到index key，否，程序退出</span></span><br><span class="line">    <span class="built_in">assert</span>(_pool.<span class="built_in">find</span>(index) != _pool.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">//将对应的buffer设置为对应的buf链表的节点</span></span><br><span class="line">    buffer-&gt;next = _pool[index];</span><br><span class="line">    _pool[index] = buffer;</span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buf_pool::malloc_mem</span><span class="params">(MEM_CAP cap, <span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//链表的头指针</span></span><br><span class="line">    io_buf* prev;</span><br><span class="line">    <span class="comment">//开辟MEM_CAP buf内存池</span></span><br><span class="line">    _pool[cap] = <span class="keyword">new</span> <span class="built_in">io_buf</span>(cap); <span class="comment">//头节点</span></span><br><span class="line">    <span class="keyword">if</span>(_pool[cap] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;new io_buf %d error\n&quot;</span>, cap);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//prev指针和_pool[MEM_CAP]都指向执行链表的首节点</span></span><br><span class="line">    prev = _pool[cap]; <span class="comment">//初始化指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//4K的buf， 预先开辟num个，供开发者使用</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;num; i++)&#123;</span><br><span class="line">        prev-&gt;next = <span class="keyword">new</span> <span class="built_in">io_buf</span>(cap);</span><br><span class="line">        <span class="keyword">if</span>(prev-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;new io_buf %d error\n&quot;</span>, cap);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//指针循环后移</span></span><br><span class="line">        prev = prev-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    _total_mem += cap/<span class="number">1024</span> * num;</span><br><span class="line">         <span class="comment">//=== 以上将4K大小的io_buf全部开辟完 ===</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;先申请一块连续的内存空间，该段内存空间能够容纳一定数量的对象；&lt;/li&gt;
&lt;li&gt;每个对象连同一个指向下一个对象</summary>
      
    
    
    
    <category term="基础组件" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"/>
    
    
    <category term="内存池" scheme="http://example.com/tags/%E5%86%85%E5%AD%98%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的list实现</title>
    <link href="http://example.com/2022/11/02/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84list%E5%AE%9E%E7%8E%B0/"/>
    <id>http://example.com/2022/11/02/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84list%E5%AE%9E%E7%8E%B0/</id>
    <published>2022-11-02T08:45:07.000Z</published>
    <updated>2022-11-02T08:59:46.331Z</updated>
    
    <content type="html"><![CDATA[<p><strong>功能：</strong>将数据进行链式存储。</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的。</p><p>链表的组成：链表由一系列<strong>结点</strong>组成。</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong>。</p><p>STL中的链表是一个双向循环链表。</p><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/list.3h4n9ekwt3y0.webp" alt="list"></p><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong>&gt;。</p><p><strong>迭代器：</strong>容器和算法之间粘合剂。</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p><strong>list简单实现</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 一个简单的List实现</span></span><br><span class="line"><span class="comment"> * 迭代器的简单实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List_Node</span></span><br><span class="line">&#123;</span><br><span class="line">    List_Node&lt;T&gt;* prev; <span class="comment">//前驱</span></span><br><span class="line">    List_Node&lt;T&gt;* next; <span class="comment">//后继</span></span><br><span class="line">    T val; <span class="comment">//数据域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//定义迭代器数据类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">List_iterator</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">typedef</span> List_iterator&lt;T&gt; iterator;</span><br><span class="line">    <span class="keyword">typedef</span> T value; <span class="comment">//数据类型</span></span><br><span class="line">    <span class="keyword">typedef</span> T&amp; ref;  <span class="comment">//引用类型</span></span><br><span class="line">    List_Node&lt;T&gt; *node;</span><br><span class="line">    <span class="built_in">List_iterator</span>(List_Node&lt;T&gt;* node): <span class="built_in">node</span>(node)&#123;&#125;</span><br><span class="line">    <span class="built_in">List_iterator</span>(): <span class="built_in">node</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//i++ 运算符重载</span></span><br><span class="line">    iterator <span class="keyword">operator</span>++()</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回对象本身</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//++i 运算符重载</span></span><br><span class="line">    iterator <span class="keyword">operator</span>++(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i-- 运算符重载</span></span><br><span class="line">    iterator <span class="keyword">operator</span>--()</span><br><span class="line">    &#123;</span><br><span class="line">        node = node-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>; <span class="comment">//返回对象本身</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//++i 运算符重载</span></span><br><span class="line">    iterator <span class="keyword">operator</span>--(<span class="type">int</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        iterator tmp = *<span class="keyword">this</span>;</span><br><span class="line">        node = node-&gt;prev;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(iterator&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;node == other.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(iterator&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;node != other.node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iterator* <span class="keyword">operator</span>-&gt;()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ref <span class="keyword">operator</span>*()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//List</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//自定义成员变量</span></span><br><span class="line">    <span class="keyword">typedef</span> List_Node&lt;T&gt;* pointer;</span><br><span class="line">    <span class="keyword">typedef</span> List_iterator&lt;T&gt; iterator;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyList</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        node = <span class="keyword">new</span> List_Node&lt;T&gt;;</span><br><span class="line">        node-&gt;next = node;</span><br><span class="line">        node-&gt;prev = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//插入</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(iterator position, T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pointer temp = <span class="keyword">new</span> List_Node&lt;T&gt;;</span><br><span class="line">        temp-&gt;val = val;</span><br><span class="line">        temp-&gt;prev = position.node;</span><br><span class="line">        temp-&gt;next = position.node-&gt;next;</span><br><span class="line">        position.node-&gt;next-&gt;prev = temp;</span><br><span class="line">        position.node-&gt;next = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">erase</span><span class="params">(iterator position)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        position.node-&gt;next-&gt;prev = position.node-&gt;prev;</span><br><span class="line">        position.node-&gt;prev-&gt;next = position.node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push_back</span><span class="params">(T val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">insert</span>(--<span class="built_in">end</span>(), val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">pointer <span class="title">pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        pointer temp = node-&gt;prev;</span><br><span class="line">        <span class="built_in">erase</span>(--<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    pointer node; <span class="comment">//代表链表的结尾位置</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printContainer</span><span class="params">(T begin, T end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *begin &lt;&lt; endl;</span><br><span class="line">        begin++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printlist</span><span class="params">(List_Node&lt;T&gt;* begin, List_Node&lt;T&gt;* end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(begin != end)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; begin-&gt;val &lt;&lt; endl;</span><br><span class="line">        begin = begin-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> v[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    MyList&lt;<span class="type">int</span>&gt; list;</span><br><span class="line">    list.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">    list.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">    list.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">    <span class="built_in">printContainer</span>(list.<span class="built_in">begin</span>(), list.<span class="built_in">end</span>());</span><br><span class="line">    list.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">printContainer</span>(list.<span class="built_in">begin</span>(), list.<span class="built_in">end</span>());</span><br><span class="line">    list.<span class="built_in">pop_back</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;-------&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printContainer</span>(v, v+<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;功能：&lt;/strong&gt;将数据进行链式存储。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;链表&lt;/strong&gt;（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的。&lt;/p&gt;
&lt;p&gt;链表的组成：链表由一系列&lt;strong&gt;结点&lt;</summary>
      
    
    
    
    <category term="STL" scheme="http://example.com/categories/STL/"/>
    
    
    <category term="list" scheme="http://example.com/tags/list/"/>
    
  </entry>
  
  <entry>
    <title>有关fd泄露的调试方法</title>
    <link href="http://example.com/2022/11/01/%E6%9C%89%E5%85%B3fd%E6%B3%84%E9%9C%B2%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2022/11/01/%E6%9C%89%E5%85%B3fd%E6%B3%84%E9%9C%B2%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95/</id>
    <published>2022-11-01T14:10:40.000Z</published>
    <updated>2022-11-12T15:32:27.994Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有关fd泄露的调试方法"><a href="#有关fd泄露的调试方法" class="headerlink" title="有关fd泄露的调试方法"></a>有关fd泄露的调试方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看全部进程</span></span><br><span class="line">ps aux</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看name进程</span></span><br><span class="line">ps aux | grep &quot;name&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看name进程（忽略grep命令本身）</span></span><br><span class="line">ps aux | grep &quot;name&quot; | grep -v &quot;grep&quot;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">得到当前进程号（可以后台一直执行该命令，并将该进程的进程号放在一个管理表中管理，监控其是否消失，消失则重启该进程--》看门狗）</span></span><br><span class="line">ps aux | grep &quot;name&quot; | grep -v &quot;grep&quot; | awk &#x27;&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">该目录存放当前系统正在运行的进程</span></span><br><span class="line">cd /proc/</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入某个进程目录，此目录存放着该进程所有的状态</span></span><br><span class="line">cd 1</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此目录存放该进程所打开的文件描述符</span></span><br><span class="line">cd fd</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看文件描述符</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">可以通过监控某个进程的文件描述符是否有异常增长来调试fd的泄露情况</span></span><br><span class="line">ls</span><br><span class="line">ls -lh /proc/&quot;pid&quot;/fd</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/proc.5hizkvtmu140.webp" alt="proc"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;有关fd泄露的调试方法&quot;&gt;&lt;a href=&quot;#有关fd泄露的调试方法&quot; class=&quot;headerlink&quot; title=&quot;有关fd泄露的调试方法&quot;&gt;&lt;/a&gt;有关fd泄露的调试方法&lt;/h3&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;tabl</summary>
      
    
    
    
    
    <category term="linux调试" scheme="http://example.com/tags/linux%E8%B0%83%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day8</title>
    <link href="http://example.com/2022/10/26/leetcode-day8/"/>
    <id>http://example.com/2022/10/26/leetcode-day8/</id>
    <published>2022-10-26T11:37:27.000Z</published>
    <updated>2022-10-26T11:41:08.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的后序遍历（迭代写法）"><a href="#二叉树的后序遍历（迭代写法）" class="headerlink" title="二叉树的后序遍历（迭代写法）"></a>二叉树的后序遍历（迭代写法）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=145 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [145] 二叉树的后序遍历</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//迭代</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(TreeNode *root, vector&lt;<span class="type">int</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode *&gt; stk;</span><br><span class="line">        <span class="comment">//记录历史访问节点</span></span><br><span class="line">        TreeNode *prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk.<span class="built_in">empty</span>() || root != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right == <span class="literal">nullptr</span> || root-&gt;right == prev)</span><br><span class="line">            &#123;</span><br><span class="line">                res.<span class="built_in">emplace_back</span>(root-&gt;val);</span><br><span class="line">                prev = root;</span><br><span class="line">                root = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                stk.<span class="built_in">emplace</span>(root);</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉树的后序遍历（迭代写法）&quot;&gt;&lt;a href=&quot;#二叉树的后序遍历（迭代写法）&quot; class=&quot;headerlink&quot; title=&quot;二叉树的后序遍历（迭代写法）&quot;&gt;&lt;/a&gt;二叉树的后序遍历（迭代写法）&lt;/h3&gt;&lt;figure class=&quot;highlight </summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="二叉树" scheme="http://example.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>TCP通信</title>
    <link href="http://example.com/2022/10/25/TCP%E9%80%9A%E4%BF%A1/"/>
    <id>http://example.com/2022/10/25/TCP%E9%80%9A%E4%BF%A1/</id>
    <published>2022-10-25T13:43:23.000Z</published>
    <updated>2022-10-26T11:47:45.808Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h3><h4 id="1、图示"><a href="#1、图示" class="headerlink" title="1、图示"></a>1、图示</h4><p><strong>TCP三次握手-四次挥手</strong><br><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/TCP三次握手-四次挥手.6j1wx5gexwo0.webp" alt="TCP三次握手-四次挥手" style="zoom: 80%;" /></p><h4 id="2、重要字段"><a href="#2、重要字段" class="headerlink" title="2、重要字段"></a>2、重要字段</h4><ul><li>seq：（sequence number）序号</li><li>ack：（acknowledgement number）确认号</li><li>标志位：<ul><li>SYN ：(SYNchronization）同步</li><li>ACK ：(ACKnowlegment）确认</li><li>FIN   :（FINish）终止<h4 id="3、三次握手过程"><a href="#3、三次握手过程" class="headerlink" title="3、三次握手过程"></a>3、三次握手过程</h4></li></ul></li></ul><ol><li><p>首先客户端先向服务器端发送一个TCP报文</p><ul><li>标记位为SYN，表示“请求建立新连接”;</li><li>序号为Seq&#x3D;X（X一般为1）（传输信息的时候每个数据包的序号)；</li><li>随后客户端进入SYN-SENT阶段（请求连接的阶段）；</li></ul></li><li><p>服务器端收到来自客户端的TCP报文之后,结束LISTEN阶段。并返回一段报文</p><ul><li>标志位为SYN和ACK，表示“确认客户端的报文Seq序号有效，服务器能正常接收客户端发送的数据，并同意创建新连接”（即告诉客户端，服务器收到了你的数据）；</li><li>序号为Seq&#x3D;y；（返回一个收到信息的数据包 并给其标序号为y）</li><li>确认号为Ack&#x3D;x+1，表示收到客户端的序号Seq并将其值加1作为自己确认号Ack的值（两端配对接收到消息 并反馈的过程；随后服务器端进入SYN-RCVD阶段。</li><li>ACK:代表确认收到消息</li></ul></li><li><p>客户端接收到来自服务器确认收到数据的TCP报文后，明确了从客户端到服务器的数据传输是正常的，结束SYN-SENT阶段，并返回一段TCP报文</p><ul><li>标志位为ACK，表示“确认收到服务器端同意连接的信号”（即告诉服务器，我知道你收到我发的数据了）；</li><li>序号为Seq&#x3D;x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值；</li><li>确认号为Ack&#x3D;y+1，表示收到服务器端序号Seq，并将其值加1作为自己的确认号Ack的值；</li><li>随后客户端进入ESTABLISHED阶段。（即成功建立了连接）<h4 id="4、四次挥手过程"><a href="#4、四次挥手过程" class="headerlink" title="4、四次挥手过程"></a>4、四次挥手过程</h4>  由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了。但是在这个TCP连接上仍然能够发送数据，直到另一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。</li></ul></li><li><p>Client发送一个FIN，以及选择号seq&#x3D;u（表示：u之前的数据已经全部发送，并且数据发到u就可以截止了，就不再有数据了），用来关闭Client到Server的数据传送。Client进入FIN_WAIT_1状态。</p></li><li><p>Server收到FIN后，发送一个请求号seq&#x3D;v和确认序号ack&#x3D;u+1给Client。Server进入CLOSE_WAIT状态。</p></li><li><p>Server发送一个FIN，请求号为最新的seq&#x3D;w和确认序号ack&#x3D;u+1，用来关闭Server到Client的数据传送。Server进入LAST_ACK状态。</p></li><li><p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为w+1。Server进入CLOSED状态，完成四次挥手。</p></li></ol><h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><h4 id="1、图示-1"><a href="#1、图示-1" class="headerlink" title="1、图示"></a>1、图示</h4><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.1jz2ylthq44g.webp" alt="TCP滑动窗口"></p><h4 id="2、过程"><a href="#2、过程" class="headerlink" title="2、过程"></a>2、过程</h4><ol><li><pre><code>发送端发起连接，声明最大段尺寸是1460，初始序号是0，窗口大小是4K，表示“我的接收缓冲区还有4K字节空闲，你发的数据不要超过4K”。接收端应答连接请求，声明最大段尺寸是1024，初始序号是8000，窗口大小是6K。发送端应答，三方握手结束。</code></pre></li><li><pre><code>发送端发出段4-9，每个段带1K的数据，发送端根据窗口大小知道接收端的缓冲区满了，因此停止发送数据。</code></pre></li><li><pre><code>接收端的应用程序提走2K数据，接收缓冲区又有了2K空闲，接收端发出段10，在应答已收到6K数据的同时声明窗口大小为2K。</code></pre></li><li><pre><code>接收端的应用程序又提走2K数据，接收缓冲区有4K空闲，接收端发出段11，重新声明窗口大小为4K。</code></pre></li><li><pre><code>发送端发出段12-13，每个段带2K数据，段13同时还包含FIN位。</code></pre></li><li><pre><code>接收端应答接收到的2K数据（6145-8192），再加上FIN位占一个序号8193，因此应答序号是8194，连接处于半关闭状态，接收端同时声明窗口大小为2K。</code></pre></li><li><pre><code>接收端的应用程序提走2K数据，接收端重新声明窗口大小为4K。</code></pre></li><li><pre><code>接收端的应用程序提走剩下的2K数据，接收缓冲区全空，接收端重新声明窗口大小为6K。</code></pre></li><li><pre><code>接收端的应用程序在提走全部数据后，决定关闭连接，发出段17包含FIN位，发送端应答，连接完全关闭。</code></pre></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;TCP通信&quot;&gt;&lt;a href=&quot;#TCP通信&quot; class=&quot;headerlink&quot; title=&quot;TCP通信&quot;&gt;&lt;/a&gt;TCP通信&lt;/h3&gt;&lt;h4 id=&quot;1、图示&quot;&gt;&lt;a href=&quot;#1、图示&quot; class=&quot;headerlink&quot; title=&quot;1、图示&quot;</summary>
      
    
    
    
    <category term="网络编程" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="TCP" scheme="http://example.com/tags/TCP/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的C++日志系统</title>
    <link href="http://example.com/2022/10/25/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84C++%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/10/25/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84C++%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-10-25T07:42:47.000Z</published>
    <updated>2022-10-25T13:44:25.257Z</updated>
    
    <content type="html"><![CDATA[<h3 id="C-日志组件"><a href="#C-日志组件" class="headerlink" title="C++日志组件"></a>C++日志组件</h3><p><strong>功能</strong></p><ol><li>日志存储： 文本文件</li><li>日志级别： debug &lt; info &lt; warn &lt; error &lt; fatal</li><li>日志内容：时间、级别、文件、行号、内容</li><li>日志翻滚：设置日志的大小</li></ol><p><strong>特点</strong></p><ul><li>线程安全</li><li>单例模式</li></ul><p><strong>url</strong></p><p><a class="link"   href="https://github.com/muhui00/simple-cpp-log.git" >https://github.com/muhui00/simple-cpp-log.git<i class="fas fa-external-link-alt"></i></a></p><p><strong><code>logger.h</code></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> utility</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义宏函数，简化使用该log时的输入操作</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(format, ...) \</span></span><br><span class="line"><span class="meta">    Logger::instence()-&gt;log(Logger::DEBUG, __FILE__, __LINE__, format, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> info(format, ...) \</span></span><br><span class="line"><span class="meta">    Logger::instence()-&gt;log(Logger::INFO, __FILE__, __LINE__, format, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> warn(format, ...) \</span></span><br><span class="line"><span class="meta">    Logger::instence()-&gt;log(Logger::WARN, __FILE__, __LINE__, format, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="keyword">error</span>(format, ...) \</span></span><br><span class="line"><span class="meta">    Logger::instence()-&gt;log(Logger::ERROR, __FILE__, __LINE__, format, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> fatal(format, ...) \</span></span><br><span class="line"><span class="meta">    Logger::instence()-&gt;log(Logger::FATAL, __FILE__, __LINE__, format, ##__VA_ARGS__);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Logger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> <span class="title class_">Level</span></span><br><span class="line">    &#123;</span><br><span class="line">        DEBUG = <span class="number">0</span>, <span class="comment">//调试</span></span><br><span class="line">        INFO,      <span class="comment">//输出信息</span></span><br><span class="line">        WARN,      <span class="comment">//警告</span></span><br><span class="line">        ERROR,     <span class="comment">//错误</span></span><br><span class="line">        FATAL,     <span class="comment">//严重错误</span></span><br><span class="line">        LEVEL_COUNT</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打开文件（记录日志内容）, filename传入参数，const不可修改</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">(<span class="type">const</span> std::string &amp; filename)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭文件</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志(写到文件里), 不定参数，日志的内容</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置日志级别（低于该级别的内容不记录）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_level</span><span class="params">(Level level)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _lev = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置日志最大文件限制</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_max</span><span class="params">(<span class="type">int</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _max = max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建单例的方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _instence = <span class="keyword">new</span> <span class="built_in">Logger</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取单例的方法</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Logger * <span class="title">instence</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//保证init方法在这个进程执行过程中只执行一次</span></span><br><span class="line">        <span class="built_in">pthread_once</span>(&amp;_once, init);</span><br><span class="line">        <span class="keyword">return</span> _instence;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//构造私有化</span></span><br><span class="line">    <span class="built_in">Logger</span>();</span><br><span class="line">    ~<span class="built_in">Logger</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日志翻滚（超过设置日志文件大小，新建日志文件记录）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rotate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Level _lev; <span class="comment">//日志级别</span></span><br><span class="line">    <span class="type">int</span> _max;   <span class="comment">//日志最大限制</span></span><br><span class="line">    <span class="type">int</span> _len;   <span class="comment">//当前日志长度</span></span><br><span class="line"></span><br><span class="line">    std::string _filename; <span class="comment">//文件名</span></span><br><span class="line">    std::ofstream _fout; <span class="comment">//文件io（文件输出流）</span></span><br><span class="line"></span><br><span class="line">    <span class="type">pthread_rwlock_t</span> _lock; <span class="comment">//文件读写锁</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * _level[LEVEL_COUNT]; <span class="comment">//记录日志级别字符串</span></span><br><span class="line">    <span class="type">static</span> Logger *_instence; <span class="comment">//单例对象</span></span><br><span class="line">    <span class="type">static</span> <span class="type">pthread_once_t</span> _once; <span class="comment">//单例锁</span></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;logger.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdexcept&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> utility;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外静态成员初始化</span></span><br><span class="line"><span class="type">const</span> <span class="type">char</span> * Logger::_level[LEVEL_COUNT] = &#123;</span><br><span class="line">    <span class="string">&quot;DEBUG&quot;</span>,</span><br><span class="line">    <span class="string">&quot;INFO&quot;</span>,</span><br><span class="line">    <span class="string">&quot;WARN&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ERROR&quot;</span>,</span><br><span class="line">    <span class="string">&quot;FATAL&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类外初始化静态成员变量</span></span><br><span class="line">Logger *Logger::_instence = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化单例锁</span></span><br><span class="line"><span class="type">pthread_once_t</span> Logger::_once = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Logger::<span class="built_in">Logger</span>() :</span><br><span class="line">    _lev(DEBUG),</span><br><span class="line">    _max(<span class="number">0</span>),</span><br><span class="line">    _len(<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化读写锁</span></span><br><span class="line">    <span class="built_in">pthread_rwlock_init</span>(&amp;_lock, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Logger::~<span class="built_in">Logger</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">pthread_rwlock_destroy</span>(&amp;_lock);</span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::open</span><span class="params">(<span class="type">const</span> std::string &amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _filename = filename;</span><br><span class="line">    _fout.<span class="built_in">open</span>(filename, std::ios::app);</span><br><span class="line">    <span class="built_in">pthread_rwlock_rdlock</span>(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span>(_fout.<span class="built_in">fail</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;open file failed&quot;</span> + filename);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取当前文件长度</span></span><br><span class="line">    _fout.<span class="built_in">seekp</span>(<span class="number">0</span>, std::ios::end);</span><br><span class="line">    _len = _fout.<span class="built_in">tellp</span>();</span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;_lock);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::close</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _fout.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::log</span><span class="params">(Level level, <span class="type">const</span> <span class="type">char</span> * file, <span class="type">int</span> line, <span class="type">const</span> <span class="type">char</span> * format, ...)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//如果该事件的日志级别小于设置的日志级别，不记录</span></span><br><span class="line">    <span class="keyword">if</span>(level &lt; _lev)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(_fout.<span class="built_in">fail</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;open file failed&quot;</span> + _filename);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*  struct tm &#123;</span></span><br><span class="line"><span class="comment">        int tm_sec;    // Seconds (0-60) </span></span><br><span class="line"><span class="comment">        int tm_min;    // Minutes (0-59) </span></span><br><span class="line"><span class="comment">        int tm_hour;   // Hours (0-23) </span></span><br><span class="line"><span class="comment">        int tm_mday;   // Day of the month (1-31) </span></span><br><span class="line"><span class="comment">        int tm_mon;    // Month (0-11) </span></span><br><span class="line"><span class="comment">        int tm_year;   // Year - 1900 </span></span><br><span class="line"><span class="comment">        int tm_wday;   // Day of the week (0-6, Sunday = 0) </span></span><br><span class="line"><span class="comment">        int tm_yday;   // Day in the year (0-365, 1 Jan = 0) </span></span><br><span class="line"><span class="comment">        int tm_isdst;  // Daylight saving time</span></span><br><span class="line"><span class="comment">    &#125;;*/</span></span><br><span class="line">    <span class="comment">//获取本地时间</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> * ptm  = <span class="built_in">localtime</span>(&amp;ticks);</span><br><span class="line">    <span class="comment">//四个字节为一个单位</span></span><br><span class="line">    <span class="type">char</span> t_buf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">memset</span>(t_buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(t_buf));</span><br><span class="line">    <span class="comment">//将ptm指向的结构格式化写入到t_buf中</span></span><br><span class="line">    <span class="built_in">strftime</span>(t_buf, <span class="built_in">sizeof</span>(t_buf), <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, ptm);</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> * fmt = <span class="string">&quot;%s %s %s:%d &quot;</span>; <span class="comment">//时间 级别 文件名：行号</span></span><br><span class="line">    <span class="comment">//获取格式化字符串长度</span></span><br><span class="line">    <span class="type">int</span> size = <span class="built_in">snprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, fmt, t_buf, _level[level], file, line);</span><br><span class="line">    <span class="comment">//printf(&quot;size = %d\n&quot;, size);</span></span><br><span class="line">    <span class="built_in">pthread_rwlock_wrlock</span>(&amp;_lock);</span><br><span class="line">    <span class="keyword">if</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * fmt_buf = <span class="keyword">new</span> <span class="type">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">snprintf</span>(fmt_buf, size + <span class="number">1</span>, fmt, t_buf, _level[level], file, line);</span><br><span class="line">        fmt_buf[size] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; fmt_buf &lt;&lt; std::endl;</span></span><br><span class="line">        <span class="comment">//写入到log文件</span></span><br><span class="line">        _fout &lt;&lt; fmt_buf;</span><br><span class="line">        _len += size;</span><br><span class="line">        <span class="keyword">delete</span>[] fmt_buf;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">//可变参数列表</span></span><br><span class="line">    va_list arg_list;</span><br><span class="line">    <span class="built_in">va_start</span>(arg_list, format);</span><br><span class="line">    <span class="comment">//将可变参数格式化写入到buf中， 返回值为最终生成字符串的长度</span></span><br><span class="line">    size = <span class="built_in">vsnprintf</span>(<span class="literal">NULL</span>, <span class="number">0</span>, format, arg_list);</span><br><span class="line">    <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">    <span class="keyword">if</span>(size &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> * vsn_buf = <span class="keyword">new</span> <span class="type">char</span>[size + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">va_start</span>(arg_list, format);</span><br><span class="line">        <span class="comment">//将可变参数格式化写入到buf中， 返回值为最终生成字符串的长度</span></span><br><span class="line">        size = <span class="built_in">vsnprintf</span>(vsn_buf, size + <span class="number">1</span>, format, arg_list);</span><br><span class="line">        <span class="built_in">va_end</span>(arg_list);</span><br><span class="line">        _fout &lt;&lt; vsn_buf;</span><br><span class="line">        _len += size;</span><br><span class="line">        <span class="comment">//std::cout &lt;&lt; vsn_buf &lt;&lt; std::endl;</span></span><br><span class="line">        _len += size;</span><br><span class="line">        <span class="keyword">delete</span>[] vsn_buf;</span><br><span class="line">    &#125;</span><br><span class="line">    _fout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="comment">//刷新缓存</span></span><br><span class="line">    _fout.<span class="built_in">flush</span>();</span><br><span class="line">    <span class="built_in">pthread_rwlock_unlock</span>(&amp;_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    std::cout &lt;&lt; t_buf &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; file &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; line &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; format &lt;&lt; std::endl;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">//超出文件大小限制</span></span><br><span class="line">    <span class="keyword">if</span>(_max &gt; <span class="number">0</span> &amp;&amp; _len &gt; _max)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">rotate</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Logger::rotate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//关闭当前文件描述符</span></span><br><span class="line">    <span class="built_in">close</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">time_t</span> ticks = <span class="built_in">time</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">tm</span> * _tm = <span class="built_in">localtime</span>(&amp;ticks);</span><br><span class="line">    <span class="type">char</span> t_buf[<span class="number">64</span>];</span><br><span class="line">    <span class="built_in">memset</span>(t_buf, <span class="number">0</span>, <span class="built_in">sizeof</span>(t_buf));</span><br><span class="line">    <span class="comment">//获取当前时间戳</span></span><br><span class="line">    <span class="built_in">strftime</span>(t_buf, <span class="built_in">sizeof</span>(t_buf), <span class="string">&quot;.%Y-%m-%d_%H-%M-%S&quot;</span>, _tm);</span><br><span class="line">    std::string filename = _filename + t_buf;</span><br><span class="line">    <span class="comment">//将日志文件以当前时间重命名备份</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">rename</span>(_filename.<span class="built_in">c_str</span>(), filename.<span class="built_in">c_str</span>()) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//抛出异常， strerror(errno) 获取错误码</span></span><br><span class="line">        <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(<span class="string">&quot;rename log file error: &quot;</span> + std::<span class="built_in">string</span>(<span class="built_in">strerror</span>(errno)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//打开新文件</span></span><br><span class="line">    <span class="built_in">open</span>(_filename);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;C-日志组件&quot;&gt;&lt;a href=&quot;#C-日志组件&quot; class=&quot;headerlink&quot; title=&quot;C++日志组件&quot;&gt;&lt;/a&gt;C++日志组件&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;日志存储： 文本文件&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="基础组件" scheme="http://example.com/categories/%E5%9F%BA%E7%A1%80%E7%BB%84%E4%BB%B6/"/>
    
    
    <category term="log" scheme="http://example.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day7</title>
    <link href="http://example.com/2022/10/25/leetcode-day7/"/>
    <id>http://example.com/2022/10/25/leetcode-day7/</id>
    <published>2022-10-25T07:36:23.000Z</published>
    <updated>2022-10-25T07:41:14.564Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有效的括号"><a href="#有效的括号" class="headerlink" title="有效的括号"></a>有效的括号</h3><p><strong>题目描述</strong><br>给定一个只包括 <code>(&#39;，&#39;)</code>，<code>&#123;&#39;，&#39;&#125;</code>，<code>[&#39;，&#39;]</code> 的字符串 s ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ol><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ol><p><strong>示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=20 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [20] 有效的括号</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果字符串的长度为奇数， 返回false</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用map键值对来保存括号类型</span></span><br><span class="line">        <span class="comment">// key为右括号， value为左括号</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">char</span>&gt; pair&#123;</span><br><span class="line">            &#123;<span class="string">&#x27;)&#x27;</span>, <span class="string">&#x27;(&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;]&#x27;</span>, <span class="string">&#x27;[&#x27;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&#x27;&#125;&#x27;</span>, <span class="string">&#x27;&#123;&#x27;</span>&#125;&#125;;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> ch : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pair.<span class="built_in">count</span>(ch))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ch值为右括号</span></span><br><span class="line">                <span class="comment">//判断栈顶元素是否与其相匹配</span></span><br><span class="line">                <span class="keyword">if</span> (stk.<span class="built_in">empty</span>() || stk.<span class="built_in">top</span>() != pair[ch])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123; <span class="comment">//弹出栈顶元素</span></span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// ch值为左括号</span></span><br><span class="line">                <span class="comment">//加入到栈中</span></span><br><span class="line">                stk.<span class="built_in">push</span>(ch);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;有效的括号&quot;&gt;&lt;a href=&quot;#有效的括号&quot; class=&quot;headerlink&quot; title=&quot;有效的括号&quot;&gt;&lt;/a&gt;有效的括号&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;给定一个只包括 &lt;code&gt;(&amp;#39;，&amp;#39;)&lt;/code</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="栈" scheme="http://example.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day6</title>
    <link href="http://example.com/2022/10/22/leetcode-day6/"/>
    <id>http://example.com/2022/10/22/leetcode-day6/</id>
    <published>2022-10-22T08:32:10.000Z</published>
    <updated>2022-10-22T10:00:45.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="合并两个有序列表"><a href="#合并两个有序列表" class="headerlink" title="合并两个有序列表"></a>合并两个有序列表</h3><p><strong>题目描述</strong><br>    将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。<br><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/image.3yzwt9tjmew0.webp" alt="image"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=21 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [21] 合并两个有序链表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">ListNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    <span class="built_in">ListNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="type">int</span> x, ListNode *next) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//迭代</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *list1, ListNode *list2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *preHead = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode *prev = preHead;</span><br><span class="line">        <span class="keyword">while</span> (list1 != <span class="literal">nullptr</span> &amp;&amp; list2 != <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (list1-&gt;val &lt; list2-&gt;val)</span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = list1;</span><br><span class="line">                list1 = list1-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                prev-&gt;next = list2;</span><br><span class="line">                list2 = list2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = prev-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        prev-&gt;next = list1 == <span class="literal">nullptr</span> ? list2 : list1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> preHead-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归</span></span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoLists2</span><span class="params">(ListNode *list1, ListNode *list2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (list2 == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归调用</span></span><br><span class="line">        <span class="keyword">if</span> (list1-&gt;val &lt;= list2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            list1-&gt;next = <span class="built_in">mergeTwoLists2</span>(list1-&gt;next, list2);</span><br><span class="line">            <span class="keyword">return</span> list1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            list2-&gt;next = <span class="built_in">mergeTwoLists2</span>(list1, list2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> list2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/31978222bda8518a6afb3c0871ac306.6c383qrdob40.webp" alt="31978222bda8518a6afb3c0871ac306"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;合并两个有序列表&quot;&gt;&lt;a href=&quot;#合并两个有序列表&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序列表&quot;&gt;&lt;/a&gt;合并两个有序列表&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;    将两个升序链表合并为一个新的 升序</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day5</title>
    <link href="http://example.com/2022/10/21/leetcode-day5/"/>
    <id>http://example.com/2022/10/21/leetcode-day5/</id>
    <published>2022-10-21T09:07:41.000Z</published>
    <updated>2022-10-21T09:18:18.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="矩阵置零"><a href="#矩阵置零" class="headerlink" title="矩阵置零"></a>矩阵置零</h3><p><strong>题目描述</strong><br>    给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用原地算法。</p><p><em>示例：</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,1,1],[1,0,1],[1,1,1]]</span><br><span class="line">输出：[[1,0,1],[0,0,0],[1,0,1]</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/muhui00/image-hosting@master/image.1tld39pszif.webp" alt="image"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=73 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [73] 矩阵置零</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setZeroes</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> row = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> col = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;&gt; pos;</span><br><span class="line">        <span class="comment">//记录元素为0的坐标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; col; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line"></span><br><span class="line">                    pos[i].<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt;::iterator it = pos.<span class="built_in">begin</span>(); it != pos.<span class="built_in">end</span>(); it++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> ir = (*it).first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pos[ir].<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> jc = pos[ir][i];</span><br><span class="line">                <span class="comment">//列置零</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> ii = <span class="number">0</span>; ii &lt; row; ii++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[ii][jc] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//行置零</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> jj = <span class="number">0</span>; jj &lt; col; jj++)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[ir][jj] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;矩阵置零&quot;&gt;&lt;a href=&quot;#矩阵置零&quot; class=&quot;headerlink&quot; title=&quot;矩阵置零&quot;&gt;&lt;/a&gt;矩阵置零&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;    给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="矩阵置零" scheme="http://example.com/tags/%E7%9F%A9%E9%98%B5%E7%BD%AE%E9%9B%B6/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day4</title>
    <link href="http://example.com/2022/10/19/leetcode-day4/"/>
    <id>http://example.com/2022/10/19/leetcode-day4/</id>
    <published>2022-10-19T10:32:25.000Z</published>
    <updated>2022-10-21T09:11:19.851Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有效的数独"><a href="#有效的数独" class="headerlink" title="有效的数独"></a>有效的数独</h3><p>题目描述<br>请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。</p><ol><li>数字 1-9 在每一行只能出现一次。</li><li>数字 1-9 在每一列只能出现一次。</li><li>数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。（请参考示例图）</li></ol><p><strong>注意</strong></p><ul><li>一个有效的数独（部分已被填充）不一定是可解的。</li><li>只需要根据以上规则，验证已经填入的数字是否有效即可。</li><li>空白格用 ‘.’ 表示。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/muhui00/image-hosting@master/250px-sudoku-by-l2g-20050714svg.11g34v5akffk.webp" alt="图片"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=36 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [36] 有效的数独</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSudoku</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;board)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> rows[<span class="number">9</span>][<span class="number">9</span>];        <span class="comment">//保存行中数字1-9出现的次数</span></span><br><span class="line">        <span class="type">int</span> colomns[<span class="number">9</span>][<span class="number">9</span>];     <span class="comment">//保存列中数字1-9出现的次数</span></span><br><span class="line">        <span class="type">int</span> subboxes[<span class="number">3</span>][<span class="number">3</span>][<span class="number">9</span>]; <span class="comment">//保存3*3矩阵中数字1-9出现的次数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化矩阵</span></span><br><span class="line">        <span class="built_in">memset</span>(rows, <span class="number">0</span>, <span class="built_in">sizeof</span>(rows));</span><br><span class="line">        <span class="built_in">memset</span>(colomns, <span class="number">0</span>, <span class="built_in">sizeof</span>(colomns));</span><br><span class="line">        <span class="built_in">memset</span>(subboxes, <span class="number">0</span>, <span class="built_in">sizeof</span>(subboxes));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> c;</span><br><span class="line">        <span class="comment">//遍历循环9*9矩阵，保存数字1-9出现的次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">9</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                c = board[i][j];</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    index = c - <span class="string">&#x27;0&#x27;</span> - <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//可以理解为一个长度为9的一维数组，顺序保存1-9数字出现的次数</span></span><br><span class="line">                    rows[i][index]++;</span><br><span class="line">                    colomns[j][index]++;</span><br><span class="line">                    <span class="comment">//可以理解为一个3*3的矩阵，顺序保存1-9数字出现的次数</span></span><br><span class="line">                    subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index]++;</span><br><span class="line">                    <span class="comment">//每个数字记录次数超过1，return false</span></span><br><span class="line">                    <span class="keyword">if</span> (rows[i][index] &gt; <span class="number">1</span> || colomns[j][index] &gt; <span class="number">1</span> || subboxes[i / <span class="number">3</span>][j / <span class="number">3</span>][index] &gt; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;有效的数独&quot;&gt;&lt;a href=&quot;#有效的数独&quot; class=&quot;headerlink&quot; title=&quot;有效的数独&quot;&gt;&lt;/a&gt;有效的数独&lt;/h3&gt;&lt;p&gt;题目描述&lt;br&gt;请你判断一个 9 x 9 的数独是否有效。只需要 根据以下规则 ，验证已经填入的数字是否有效即可。&lt;</summary>
      
    
    
    
    <category term="leetcode" scheme="http://example.com/categories/leetcode/"/>
    
    
    <category term="有效的数独" scheme="http://example.com/tags/%E6%9C%89%E6%95%88%E7%9A%84%E6%95%B0%E7%8B%AC/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day3</title>
    <link href="http://example.com/2022/10/18/leetcode-day3/"/>
    <id>http://example.com/2022/10/18/leetcode-day3/</id>
    <published>2022-10-18T07:52:21.000Z</published>
    <updated>2022-10-18T08:05:59.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两个数组的交集-II"><a href="#1-两个数组的交集-II" class="headerlink" title="1 两个数组的交集 II"></a>1 两个数组的交集 II</h3><p><strong>题目描述</strong><br>    给你两个整数数组 nums1 和 nums2 ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=350 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [350] 两个数组的交集 II</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(m+n)</span></span><br><span class="line">    <span class="comment">//空间复杂度：O(min(m,n))</span></span><br><span class="line">    <span class="comment">//只关系到查询操作，因此每次读取nums2中的一部分数据，并进行处理即可,内存有限适用于该方法。</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.<span class="built_in">size</span>() &gt; nums2.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">intersect</span>(nums2, nums1);</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历循环nums1，并统计相同数据个数</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums1)</span><br><span class="line">        &#123;</span><br><span class="line">            ++m[num];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历循环nums2，并得到交集</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums2)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// m[num] != 0 说明num在nums1存在</span></span><br><span class="line">            <span class="keyword">if</span> (m[num])</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(num);</span><br><span class="line">                <span class="comment">//取最小出现次数</span></span><br><span class="line">                m[num]--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当出现次数为0时，从m中删除该元素， 该元素的交集统计完成</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (m[num] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                m.<span class="built_in">erase</span>(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//排序 双指针</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(mlogm+nlogn)</span></span><br><span class="line">    <span class="comment">//O(min(m,n))</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersect2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, vector&lt;<span class="type">int</span>&gt; &amp;nums2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums2.<span class="built_in">begin</span>(), nums2.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; nums1.<span class="built_in">size</span>() &amp;&amp; p2 &lt; nums2.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                p1++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &gt; nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(nums1[p1]);</span><br><span class="line">                p1++;</span><br><span class="line">                p2++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums1&#123;<span class="number">4</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums2&#123;<span class="number">9</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    Solution s;</span><br><span class="line">    result = s.<span class="built_in">intersect2</span>(nums1, nums2);</span><br><span class="line">    <span class="built_in">print</span>(result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-买卖股票的最佳时机"><a href="#2-买卖股票的最佳时机" class="headerlink" title="2 买卖股票的最佳时机"></a>2 买卖股票的最佳时机</h3><p><strong>题目描述</strong><br>    给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。<br>    你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。<br>    返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=121 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [121] 买卖股票的最佳时机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//暴力法</span></span><br><span class="line">    <span class="comment">//超出时间限制</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; prices.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, prices[j] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//一次遍历</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(1)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> max_price = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> price : prices)</span><br><span class="line">        &#123;</span><br><span class="line">            max_price = <span class="built_in">max</span>(max_price, price - min_price);</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max_price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//动态规划（一维）</span></span><br><span class="line">    <span class="comment">//状态方程 dp[i] = max(dp[i-1], prices[i] - min_price)</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(n)</span></span><br><span class="line"><span class="comment">//空间复杂度：O(n)</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = prices.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> min_price = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="comment">//边界条件</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            min_price = <span class="built_in">min</span>(min_price, prices[i]);</span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>], prices[i] - min_price);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; prices&#123;<span class="number">7</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    Solution s;</span><br><span class="line">    <span class="type">int</span> v = s.<span class="built_in">maxProfit3</span>(prices);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;v = %d\n&quot;</span>, v);</span><br><span class="line">    <span class="comment">/* code */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-两个数组的交集-II&quot;&gt;&lt;a href=&quot;#1-两个数组的交集-II&quot; class=&quot;headerlink&quot; title=&quot;1 两个数组的交集 II&quot;&gt;&lt;/a&gt;1 两个数组的交集 II&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;    给</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_day2</title>
    <link href="http://example.com/2022/10/17/leetcode-day2/"/>
    <id>http://example.com/2022/10/17/leetcode-day2/</id>
    <published>2022-10-17T02:22:05.000Z</published>
    <updated>2022-10-18T08:06:15.344Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1 两数之和"></a>1 两数之和</h3><p><strong>题目描述</strong><br>    给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那两个整数，并返回它们的数组下标。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//暴力遍历</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = (<span class="type">int</span>)nums.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    s.<span class="built_in">push_back</span>(i);</span><br><span class="line">                    s.<span class="built_in">push_back</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//哈希表</span></span><br><span class="line">    <span class="comment">//使用哈希表，可以将寻找 target - x 的时间复杂度降低到从 O(N)降低到O(1)。这样     我们创建一个哈希表，对于每一个 x，我们首先查询哈希表中是否存在target - x，然后将     x 插入到哈希表中，即可保证不会让 x 和自己匹配。</span></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum_hash</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> target)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// key : nums[], value : i</span></span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; hash;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//迭代查找</span></span><br><span class="line">            <span class="keyword">auto</span> it = hash.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (it != hash.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;it-&gt;second, i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//循环插入</span></span><br><span class="line">            hash[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    <span class="type">int</span> target = <span class="number">6</span>;</span><br><span class="line">    Solution s;</span><br><span class="line">    result = s.<span class="built_in">twoSum</span>(nums, target);</span><br><span class="line">    cout &lt;&lt; result[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; result[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-合并两个有序数组"><a href="#2-合并两个有序数组" class="headerlink" title="2 合并两个有序数组"></a>2 合并两个有序数组</h3><p><strong>题目描述</strong><br>    给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。<br>    请你合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序排列。<br><strong>注意</strong>：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @lc app=leetcode.cn id=88 lang=cpp</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * [88] 合并两个有序数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// @lc code=start</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//直接合并后排序</span></span><br><span class="line">    <span class="comment">//时间复杂度：O((m+n)log(m+n))</span></span><br><span class="line">    <span class="comment">//空间复杂度：O(log(m+n))</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[m + i] = nums2[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//双指针</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(m+n)</span></span><br><span class="line">    <span class="comment">//空间复杂度：O(m+n)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = <span class="number">0</span>, p2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> sorted[m + n];</span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt; m || p2 &lt; n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p1 == m)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p2 == n)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[p1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">            sorted[p1 + p2 - <span class="number">1</span>] = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m + n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            nums1[i] = sorted[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//逆向双指针</span></span><br><span class="line">    <span class="comment">//时间复杂度：O(m+n)</span></span><br><span class="line">    <span class="comment">//空间复杂度：O(1)</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge3</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt; &amp;nums2, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> p1 = m - <span class="number">1</span>, p2 = n - <span class="number">1</span>; <span class="comment">//指针指向数组的最后一个元素</span></span><br><span class="line">        <span class="type">int</span> cur;</span><br><span class="line">        <span class="type">int</span> tail = m + n <span class="number">-1</span>; <span class="comment">//指向合并后数组最后一个位置</span></span><br><span class="line">        <span class="keyword">while</span>(p1 &gt;= <span class="number">0</span> || p2 &gt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(p1 == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(p2 == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums1[p1] &lt; nums2[p2])</span><br><span class="line">            &#123;</span><br><span class="line">                cur = nums2[p2--];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cur = nums1[p1--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[tail--] = cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; nums2 = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    Solution s;</span><br><span class="line">    s.<span class="built_in">merge3</span>(nums1, <span class="number">3</span>, nums2, <span class="number">3</span>);</span><br><span class="line">    for_each(nums1.<span class="built_in">begin</span>(), nums1.<span class="built_in">end</span>(), print);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @lc code=end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-两数之和&quot;&gt;&lt;a href=&quot;#1-两数之和&quot; class=&quot;headerlink&quot; title=&quot;1 两数之和&quot;&gt;&lt;/a&gt;1 两数之和&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;br&gt;    给定一个整数数组 nums 和一个整数目标值 ta</summary>
      
    
    
    
    <category term="数据结构" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="leetcode" scheme="http://example.com/tags/leetcode/"/>
    
  </entry>
  
</feed>
