<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Protobuf数据序列化</title>
    <url>/2022/04/15/Protobuf%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="1、Protocol-Buffer介绍"><a href="#1、Protocol-Buffer介绍" class="headerlink" title="1、Protocol Buffer介绍"></a>1、Protocol Buffer介绍</h2><p>Protocol Buffer( 简称 Protobuf) 是Google公司内部的混合语言数据标准，它是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，很适合做数据存储或RPC 数据交换格式。</p>
<p>Protobuf是一个纯粹的展示层协议，可以和各种传输层协议一起使用，Protobuf的文档也非常完善。google 提供了多种语言的实现：java、c#、c++、go 和 python，每一种实现都包含了相应语言的编译器以及库文件。</p>
<p>Protobuf支持的数据类型相对较少，不支持常量类型。由于其设计的理念是纯粹的展现层协议，目前并没有一个专门支持Protobuf的RPC框架。</p>
<h2 id="2、Protobuf使用流程"><a href="#2、Protobuf使用流程" class="headerlink" title="2、Protobuf使用流程"></a>2、Protobuf使用流程</h2><h3 id="2-1-准备数据"><a href="#2-1-准备数据" class="headerlink" title="2.1 准备数据"></a>2.1 准备数据</h3><ul>
<li>复合类型: 结构体&#x2F; 类 <ul>
<li>要序列化的数据</li>
<li>基础类型</li>
</ul>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 要序列化的数据</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Persion</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> id;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="2-2、创建-proto文件，语法格式"><a href="#2-2、创建-proto文件，语法格式" class="headerlink" title="2.2、创建.proto文件，语法格式"></a>2.2、创建.proto文件，语法格式</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// protobuf的版本</span></span><br><span class="line"><span class="comment">// proto2</span></span><br><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;	</span><br><span class="line"><span class="comment">// 导入另外一个proto文件</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;filename.proto&quot;</span>;</span><br><span class="line"><span class="comment">// 组织Persion结构体</span></span><br><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line">message 关键字(相当于被创建出的类的名字)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 成员变量</span></span><br><span class="line">	数据类型 变量名 = 变量的编号;	<span class="comment">// 编号从1开始, 不能重复</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>repeated限定修饰符（使用数组）</li>
<li>使用import导入另外一个proto文件</li>
<li>使用package添加命名空间</li>
<li>示例</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Persion.proto</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">// 导入另外一个proto文件</span><br><span class="line">import &quot;Info.proto&quot;;</span><br><span class="line">// 添加命名空间</span><br><span class="line">package namespace;	// Persion类属于namespace这个命名空间</span><br><span class="line">enum TypeValue</span><br><span class="line">&#123;</span><br><span class="line">	value1 = 0;	// protbuf中第一个枚举值必须为0</span><br><span class="line">	value2 = 6;</span><br><span class="line">	value3 = 9;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message Persion</span><br><span class="line">&#123;</span><br><span class="line">    int32 id = 1;   // 编号从1开始</span><br><span class="line">    repeated bytes name = 2;  //repeated修饰name可以在程序中创建多个, 在程序中作为动态数组来使用</span><br><span class="line">    int32 age = 3;</span><br><span class="line">    TypeValue value = 4;</span><br><span class="line">    Info info = 5;	// Info对象, 导入的proto文件中的类</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// Info.proto</span><br><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line">// 添加命名空间</span><br><span class="line">package namespace;	// Persion类属于namespace这个命名空间</span><br><span class="line">message Info</span><br><span class="line">&#123;</span><br><span class="line">    bytes address = 1; </span><br><span class="line">    int32 number = 2;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<ul>
<li>.proto数据类型</li>
</ul>
<table>
<thead>
<tr>
<th>.proto类型</th>
<th>**C++**类型</th>
<th><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td>double</td>
<td>double</td>
<td>64位浮点数</td>
</tr>
<tr>
<td>float</td>
<td>float</td>
<td>32位浮点数</td>
</tr>
<tr>
<td>int32</td>
<td>int32</td>
<td>32位整数</td>
</tr>
<tr>
<td>int64</td>
<td>int64</td>
<td>64位整数</td>
</tr>
<tr>
<td>uint32</td>
<td>uint32</td>
<td>32位无符号整数</td>
</tr>
<tr>
<td>uint64</td>
<td>uint64</td>
<td>64位无符号整数</td>
</tr>
<tr>
<td>sint32</td>
<td>sint32</td>
<td>32位整数，处理负数效率比int32更高</td>
</tr>
<tr>
<td>sint64</td>
<td>sint64</td>
<td>64位整数，处理负数效率比int64更高</td>
</tr>
<tr>
<td>fixed32</td>
<td>uint32</td>
<td>总是4个字节。如果数值总是比总是比228大的话，这个类型会比uint32高效。</td>
</tr>
<tr>
<td>fixed64</td>
<td>uint64</td>
<td>总是8个字节。如果数值总是比总是比256大的话，这个类型会比uint64高效。</td>
</tr>
<tr>
<td>sfixed32</td>
<td>int32</td>
<td>总是4个字节</td>
</tr>
<tr>
<td>sfixed64</td>
<td>int64</td>
<td>总是8个字节</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td>布尔类型</td>
</tr>
<tr>
<td>string</td>
<td>string</td>
<td>一个字符串必须是UTF-8编码或者7-bit ASCII编码的文本</td>
</tr>
<tr>
<td>bytes</td>
<td>string</td>
<td>处理多字节的语言字符、如中文</td>
</tr>
<tr>
<td>enum</td>
<td>enum</td>
<td>枚举</td>
</tr>
<tr>
<td>message</td>
<td>object of class</td>
<td>自定义的消息类型</td>
</tr>
</tbody></table>
<h3 id="2-2、使用protobuf编译器生成C-类"><a href="#2-2、使用protobuf编译器生成C-类" class="headerlink" title="2.2、使用protobuf编译器生成C++类"></a>2.2、使用protobuf编译器生成C++类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># protobuf编译器, 编译源码得到的 protoc.exe</span><br><span class="line"># 语法</span><br><span class="line"># --cpp_out 生成的c++类的位置</span><br><span class="line"></span><br><span class="line">protoc.exe xxx.proto --cpp_out=目录</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<h3 id="2-3、使用C-API来读写消息"><a href="#2-3、使用C-API来读写消息" class="headerlink" title="2.3、使用C++ API来读写消息"></a>2.3、使用C++ API来读写消息</h3><ul>
<li>读: <code>变量名()</code></li>
<li>写: <code>set_变量名(arg1, arg2, ...)</code></li>
<li>部分C++接口函数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Person p;</span><br><span class="line">//序列化 output为传出参数</span><br><span class="line">p.SerializeToString(std::string* output);</span><br><span class="line"></span><br><span class="line">//解析</span><br><span class="line">Person pp;</span><br><span class="line">pp.ParseFromString(output);</span><br></pre></td></tr></table></figure>

<p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p>
<p>2.4、VS中的使用</p>
<ul>
<li>将生成的C++类和头文件添加到项目</li>
<li>在项目文件中的头文件中引用</li>
<li>注意：VS配置需要在C&#x2F;C++-》预处理器-》添加宏”PROTOBUF_USE_DLLS”</li>
</ul>
]]></content>
      <tags>
        <tag>Protobuf</tag>
      </tags>
  </entry>
</search>
